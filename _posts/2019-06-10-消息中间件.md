---
title: 消息中间件
tags: MQ
renderNumberedHeading: true
grammar_cjkRuby: true
---

# 一、初识消息队列MQ

## 1. 为什么要引入消息中间件？

  由一个场景引入：假设现在有多个学生需要问老师问题，传统场景中这多个学生需要排队等待，假设有4个学生需要请教，每个学生会问5分钟，那么完成这个场景需要20分钟，且每个学生都需要等待一定的时间。这个场景可以看到存在很多问题：一是在高并发场景下，系统（老师）压力很大；二是系统耦合度很高；三是系统效率很低，需要很多时间....这样的一个生活场景需求在开发应用系统中也很常见，而按照传统的“串行”模式，系统可用性很低，因此需要一些措施来提高系统可用性；
  比如在这个生活场景中，我们可以假设有第三方“班长”，当后面有同学也要提问时，可以按照要求的格式将问题写下来交给“班长”，不需要等待，提交之后就去干其他的事，老师可以按照提交的先后顺序在有空的时候处理这些问题，其实这样的一些措施就发挥了以下作用：
 - 应用解耦：后面的同学不再等待调用“老师”，解决了耦合调用的问题；
 - 异步处理：同学提问后不需要马上得到老师的解答，老师可以在有空的时候去解决；
 - 限流削峰：即当有巨多请求时，不会同时给到“老师”，“班长”可以分担一部分的流量，也就起到了抵御洪峰流量，达到保护主业务的目的。
  从这个生活场景过渡到系统之间直接调用存在的问题，比如一个订单系统，需要调用库存系统，再调用支付系统，再调用物流系统，这样的链式调用存在几个大问题：
 - 系统之间接口耦合比较严重：当其中某个系统有改动时，其他系统也要跟着改动，开发联调的效率很低；
 - 面对大流量并发时，容易被冲垮：比如秒杀系统中上游系统发起下单购买操作后，下游系统需要完成秒杀业务逻辑（读取订单、库存检查、库存冻结、余额检查、余额冻结、订单生成、余额扣减、库存扣减、生成流水、余额解冻、库存解冻），所以当上游有大量请求时，下游系统的压力很大，需要“被保护”；
 - 等待同步存在性能问题。
  为了解决上述的三种问题，在设计系统时需要达到：
 - 要做到系统解耦，当新的模块接来时，可以做到代码改动最小-即能够解耦；
 - 设置流量缓冲池，可以让后端系统按照自身吞吐能力进行消费，不被冲垮-即能够削峰；
 - 强弱依赖梳理能够将非关键调用链路的操作异步化并提升整体系统的吞吐能力-即能够异步。

## 2. MQ是什么？

  可查看官网介绍：面向消息的中间件MOM是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成，通过消息传递和消息排队模型在分布式环境下提供应用解耦、弹性伸缩、冗余存储、流量削峰、异步通信、数据同步等功能；
  大致的过程就是：发送者把消息发送给消息服务器，消息服务器将消息存放在若干队列、主题中，在合适的时候，消息服务器会将消息转发给接受者，在这个过程中，发送和接收是异步的，也就是发送无需等待，而且发送者和接收者的生命周期没有必然关系。


## 3. MQ能做什么？

  这个问题在1中就已经提到，MQ的主要作用就是解耦、削峰、异步。

## 4. MQ有哪些分类？
  
  MQ有两种模式：
1. 点对点消息传递模式——Queue：
  生产者生产消息到队列中，消费者从队列中消费消息，其中消费方式可能有以下几种：	
 - 先生产，只启动一个消费者：这种情况下消费者会消费队列中全部的消息；
 - 先生产，先启动一个消费者，再启动另一个消费者：这种情况下只有第一个消费者可以消费，后面的消费者不能再接收消息；
 - 先启动两个消费者，再生产消息：这种情况下两个消费者会平均分配队列中的消息；
这种模式的特点有：		
 - 每个消息只能有一个消费者，类比1对1的关系；
 - 消息的生产者和消费者之间没有时间上的相关性，无论消费者在生产者发送消息的时候是否处于运行状态，消费者都可以提取消息；
 - 消息被消费后队列中不会再存储，所以消费者不会消费到已经被接收的消息；
 - 一个queue可以有多个消费者，且可以实现负载均衡；
 - 点对点模式下，消费者是主动拉取数据
2. 发布-订阅模式——topic:
  生产者生产消息发布到topic中，订阅者从topic中接收消息，可能有以下几种消费情况：
 - 先启动订阅者，后启动生产者，此时生产者发布的消息，每个订阅者都能收到，消息出队的个数为订阅者的数量*发布者发布的消息数量；
 - 先启动生产者，后启动订阅者，此时在订阅者启动之前的消息，订阅者无法收到。
  这种模式有以下几个特点：
 - 每个消息可以有多个消费者，类比1对N的关系；
 - 消息的生产者和消费者之间又时间上的相关性，消费者只能接收订阅之后的消息；
 - 生产者生产时，topic不保存消息，它是无状态的不落地，假如无人订阅就去生产，它就是一条废消息，所以一般先启动消费者再启动生产者。
 - 类比于公众号，订阅之后会“推”给订阅者，这种方式会存在一个问题，就是“推”的速度取决于topic，而订阅者的处理速度不一致可能造成资源的浪费；因此发布订阅模式中有两种方法：一种是订阅者主动拉取消息，一种是topic推送消息。
3.  queue  && topic：
 - 工作模式：queue是“负载均衡”模式，如果当前没有消费者，消息也不会丢弃；如果有多个消费者，那么一条消息也只会发送给一个消费者，并且要求消费者ack信息；而topic是订阅-发布模式，如果当前没有订阅者，消息将会被丢弃，如果有多个订阅者，那么这些订阅者都会收到消息；
 - 有无状态：queue数据默认会在mq服务器上以文件形式保存；topic模式是无状态的；
 - 传递完整性：queue中消息不会丢弃；topic中如果没有订阅者，消息会被丢弃；
 - 处理效率：queue模式中由于一条消息只会发送给一个消费者，所以就算消费者再多，性能也不会有明显降低；topic中由于消息是要按照订阅者的数量进行复制，所以处理性能会随着订阅者的增加而明显降低，并且还要结合不同消息协议自身的性能差异。

# 二、JMS

## 2.1 JavaEE

  首先JavaEE是一套使用java进行企业级应用开发的一直遵循的核心规范工业标准，JavaEE提供了一个基于组件的方法来加快设计、开发、装配以及部署企业应用程序，其中包括：
  JDBC、JNDI、EJB、RMI(远程方法调用）、Java IDL/CORBA、JSP、Servlet、XML、JMS、JTA（java事务API）、JTS(Java 事务服务）、JavaMail、JAF

## 2.2 JMS(Java 消息服务）

  即两个应用程序之间进行异步通信的API，为标准消息协议和消息服务提供了一组通用接口、包括创建、发送、读取消息等，用于支持JAVA应用程序开发，当两个应用程序使用JMS进行通信时，它们之间并不是直接相连的，而是通过一个共同的消息收发服务组件关联起来以达到解耦/异步削峰的效果。
  JMS的消费者可以通过两种方式来消费消息：
  （1）同步阻塞方式：消费者或订阅者通过receive（）或receive(时间）来接收消息，在接收到消息之前或超时之前一直阻塞；
  （2）异步非阻塞方式：订阅者或消费者注册为一个消息监听器，通过监听的方式来消费消息。当消息到达时，系统自动调用监听器的onMessage()方法。

## 2.3 MQ中间件的其它落地产品：

  ![Diagram](./attachments/1597826165946.drawio.html)
 -  JMS的组成结构：
  JMS由四大元素组成：
 - JMS provider ：实现JMS接口和规范的消息中间件，也就是MQ服务；
 - JMS procuder：消息生产者，创建和发送JMS消息的客户端应用；
 - JMS consumer：消息消费者，接收和处理JMS消息的客户端应用；
 - JMS message：消息，由消息头、消息体、消息属性构成。
![Diagram](./attachments/1597888662826.drawio.html)
 其中，JMS message又包括：
 - 消息头：包含以下常用属性：JMSDestination（消息目的地，即topic 、queue)，JMSDeliveryMode（签收模式，持久化、非持久化）、JMSExpiration（过期时间，默认永不过期），JMSPriority（优先级，0-9级，0-4级为普通，5-9级为加急，4为默认级别），JMSMessageID（唯一识别每个消息的标识）。
 - 消息体：即封装具体的消息数据，有多种消息体格式，而且发送和接收的消息体类型必须一致；
 - 消息属性：如果需要除消息头字段以外的值，那么可以使用消息属性，以属性名和属性值的形式，起到识别、去重、重点标注的作用。

## 2.4 JMS的可靠性：

  JMS的可靠性基本上要从4个角度回答：持久性、事务、签收、broker;
  
 - （1）持久性：持久性有两种设置：持久化和非持久化
  在queue中，如果参数设置为非持久化，那么当服务器宕机后，消息就不存在；如果设置为持久化，服务器宕机后，消息还是存在的，而queue的默认设置是“持久化”消息，这种模式保证了这些消息只被传送一次和成功使用一次，对于这些消息，可靠性是优先考虑的因素，另外确保持久性消息传送至目标后，消息服务在向消费者传送它们之前不会丢失这些消息。
   在topic中，一般要先启动订阅再启动生产，因为如果没有订阅，生产的消息将会变成废消息，这样一来持久和非持久就没有什么意义了。在先启动订阅再启动生产的消费方式下，设置为持久化模式，如果订阅者先“注册”（即先启动一次）后离线（宕机），然后生产者发送消息，此时无论订阅者是否在线，都会接收到，不在线的话下次连接时会把没有接收过的消息都接收下来，类比微信公众号的订阅。
 -  （2）事务：事务偏向于生产者
   对于生产者而言，事务的参数设为false和true是不一样的，如果设为false，只要执行send，消息就会进入队列中，但是设为true之后就是以事务提交，执行send之后必须执行commit，必须要先“提交”消息才能进入到队列中。用事务可以保证批处理异常情况下进行回滚。
   对于消费者而言，创建session时事务的参数也可以设为true和false，在queue中，如果参数为false，那么消息只会被消费一次。但是当参数设为true，且没有提交时，会出现问题，消息可以被重复消费。
 -  （3）签收：签收偏向于消费者
   创建session时还有一个参数是“签收”，可以设为自动签收（默认）、手动签收、允许带副本的重复签收。有以下几种情形：（a）在非事务情形下，自动签收时在queue中是符合的，如果改为手动签收会出现重复消费，此时消费者客户端需要调用“确认”方法。（b）在事务情形下，如果设为手动签收，即使没有在消费者客户端调用“确认”，也不会出现重复消费，此时其实默认为自动签收。如果没有“commit”，手动签收时也调用了确认，还是会出现重复消费的问题，说明事务是大于签收机制的。
   **因此对于事务性会话，当一个事务被成功提交则消息被自动签收，如果事务回滚，则消息会被再次传送，非事务性会话中，消息何时被确认取决于创建会话时的应答模式。**
 - （4）多节点集群
   