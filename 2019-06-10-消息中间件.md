---
title: 消息中间件
tags: MQ
renderNumberedHeading: true
grammar_cjkRuby: true
---

# 一、初识消息队列MQ

## 1. 为什么要引入消息中间件？

  由一个场景引入：假设现在有多个学生需要问老师问题，传统场景中这多个学生需要排队等待，假设有4个学生需要请教，每个学生会问5分钟，那么完成这个场景需要20分钟，且每个学生都需要等待一定的时间。这个场景可以看到存在很多问题：一是在高并发场景下，系统（老师）压力很大；二是系统耦合度很高；三是系统效率很低，需要很多时间....这样的一个生活场景需求在开发应用系统中也很常见，而按照传统的“串行”模式，系统可用性很低，因此需要一些措施来提高系统可用性；
  比如在这个生活场景中，我们可以假设有第三方“班长”，当后面有同学也要提问时，可以按照要求的格式将问题写下来交给“班长”，不需要等待，提交之后就去干其他的事，老师可以按照提交的先后顺序在有空的时候处理这些问题，其实这样的一些措施就发挥了以下作用：
 - 应用解耦：后面的同学不再等待调用“老师”，解决了耦合调用的问题；
 - 异步处理：同学提问后不需要马上得到老师的解答，老师可以在有空的时候去解决；
 - 限流削峰：即当有巨多请求时，不会同时给到“老师”，“班长”可以分担一部分的流量，也就起到了抵御洪峰流量，达到保护主业务的目的。
  从这个生活场景过渡到系统之间直接调用存在的问题，比如一个订单系统，需要调用库存系统，再调用支付系统，再调用物流系统，这样的链式调用存在几个大问题：
 - 系统之间接口耦合比较严重：当其中某个系统有改动时，其他系统也要跟着改动，开发联调的效率很低；
 - 面对大流量并发时，容易被冲垮：比如秒杀系统中上游系统发起下单购买操作后，下游系统需要完成秒杀业务逻辑（读取订单、库存检查、库存冻结、余额检查、余额冻结、订单生成、余额扣减、库存扣减、生成流水、余额解冻、库存解冻），所以当上游有大量请求时，下游系统的压力很大，需要“被保护”；
 - 等待同步存在性能问题。
  为了解决上述的三种问题，在设计系统时需要达到：
 - 要做到系统解耦，当新的模块接来时，可以做到代码改动最小-即能够解耦；
 - 设置流量缓冲池，可以让后端系统按照自身吞吐能力进行消费，不被冲垮-即能够削峰；
 - 强弱依赖梳理能够将非关键调用链路的操作异步化并提升整体系统的吞吐能力-即能够异步。

## 2. MQ是什么？

  可查看官网介绍：面向消息的中间件MOM是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成，通过消息传递和消息排队模型在分布式环境下提供应用解耦、弹性伸缩、冗余存储、流量削峰、异步通信、数据同步等功能；
  大致的过程就是：发送者把消息发送给消息服务器，消息服务器将消息存放在若干队列、主题中，在合适的时候，消息服务器会将消息转发给接受者，在这个过程中，发送和接收是异步的，也就是发送无需等待，而且发送者和接收者的生命周期没有必然关系。
![Diagram](./attachments/1597826165946.drawio.html)

## 3. MQ能做什么？

  这个问题在1中就已经提到，MQ的主要作用就是解耦、削峰、异步。

## 4. MQ有哪些分类？

  MQ有两种模式：
 1. 点对点消息传递模式——Queue：
  生产者生产消息到队列中，消费者从队列中消费消息，其中消费方式可能有以下几种：	
 - 先生产，只启动一个消费者：这种情况下消费者会消费队列中全部的消息；
 - 先生产，先启动一个消费者，再启动另一个消费者：这种情况下只有第一个消费者可以消费，后面的消费者不能再接收消息；
 - 先启动两个消费者，再生产消息：这种情况下两个消费者会平均分配队列中的消息；
这种模式的特点有：		
 - 每个消息只能有一个消费者，类比1对1的关系；
 - 消息的生产者和消费者之间没有时间上的相关性，无论消费者在生产者发送消息的时候是否处于运行状态，消费者都可以提取消息；
 - 消息被消费后队列中不会再存储，所以消费者不会消费到已经被接收的消息；
 - 一个queue可以有多个消费者，且可以实现负载均衡；
2.  发布-订阅模式——topic:
    生产者生产消息发布到topic中，订阅者从topic中接收消息，这种模式有以下几个特点：
 - 每个消息可以有多个消费者，类比1对N的关系；
 - 消息的生产者和消费者之间又时间上的相关性，消费者只能接收订阅之后的消息；
 - 生产者生产时，topic不保存消息，它是无状态的不落地，假如无人订阅就去生产，它就是一条废消息，所以一般先启动消费者再启动生产者。

   
   